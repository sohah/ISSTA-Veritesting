\section{Evaluation}
\label{sec:results}
\subsection{Experimental Setup}
%
We implemented the above mentioned transformations as a wrapper around the Symbolic PathFinder~\cite{spf} tool.
%
To make use of region summaries in Symbolic PathFinder, we use an existing feature of SPF named \textit{listener}.
%
A listener is a method defined within SPF that is called for every bytecode instruction executed by SPF.
%
\tool\ adds a path merging listener to SPF that, on every program location to be executed, checks if the next
instruction is a conditional branch instruction with at least one symbolic operand.
%
On finding such a symbolic branch condition, \tool\ attempts to compute a static summary of all multi-path
regions in the method which contains the current program location.
%
After this Just-In-Time static analysis, if \tool\ summarized the multi-path region that begins at the current program
location, \tool\ computes the canonical region corresponding to the current program location by reading inputs from
and writing outputs to the stack and the heap.
%
Finally, it conjuncts the canonical region summary with the path condition and resumes symbolic execution at the
bytecode offset of the end of the region.
%
\tool\ wraps around SPF and can be configured to either run SPF without any path merging or run SPF with the
following four path-merging features enabled.

(1) \tool\ only transforms multi-path regions with a single exit point to their canonical form.
This includes multi-path regions that have local, stack, field, or array outputs.
%
\tool\ substitutes local inputs into the Ranger IR representation of the multi-path region, and constructs SSA form
Ranger IR for all field and array accesses in the region using its runtime context.
%
The SSA form representation of all field and array accesses allows the Ranger IR to be simplified uniformly across all
variable types which reduces the size of the region summary and improves performance.
%
While our current implementation of \tool\ cannot transform summaries with symbolic object and array
references, it is capable of summarizing reads and writes to arrays with symbolic indices.
%
(2) \tool\ uses multi-path region
summaries that make method calls which have also been statically summarized.
%
Method summaries are inlined into
the multi-path region summary based on the dynamic type of the method.
%
(3) \tool\ uses single-path cases to allow regions to have more than one exit point.
%
These exit points take the form of new object allocations and exceptional behavior present in the region.
%
(4) \tool\ converts multiple exit points that return
control flow from the region to its caller into a single control flow-returning exit point.
%
This feature allows summarization of multiple {\tt return} instructions in a region into a single control-flow
returning exit point.
%
Instead of a single return value, such an exit point returns a formula to its caller, which predicates
each return value on its corresponding condition in the region.

We used the control-flow graph recovered by Wala~\cite{Wala} to bootstrap our static statement recovery process.
%
%While we found our static statement recovery was capable of summarizing thousands of regions in Java library code, many
%of these summaries could not be instantiated due to JPF\rq s use of native peers~\cite{jpf-mji}.
%
%To avoid these unnecessary instantiation failures and target our static statement recovery towards the benchmark code,
%we turned off statement recovery across a few Java library packages in Wala on all benchmarks.
%
We ran the above implementation using the incremental solving mode of Z3 using the bitvector theory.
%
The incremental solving mode provides only the last constructed constraint to the solver instead of passing the entire
path condition every time a query is to be solved.
%
Since path-merging can create large formulas in the path condition, the incremental solving mode provided a crucial
benefit in reducing the number of times large formulas had to be passed to the solver.
%
Finally, we also built in a heuristic that estimates the number of paths through a canonical region summary and compares
it to the number of exit points present in the region.
%
The canonical region summary is used only if the estimated number of paths is greater than the number of exit points in
the region.
%
\subsection{Evaluation}
%
In order to evaluate the performance of \tool, we used the following nine benchmarking programs commonly used to
evaluate symbolic execution performance.
%
Eight of these programs were provided by Wang et al.~\cite{dgse} which also includes a translation of the
Siemens suite to Java.
%
(1) Wheel Brake System (WBS)~\cite{yang2014directed} is a synchronous reactive
component developed to make aircraft brake safely when taxing, landing, and during a rejected take-off.
%
(2) Traffic Collision Avoidance System (TCAS) is part of a suite of programs commonly referred to as the Siemens
suite~\cite{siemens-benchmarks}. TCAS is a system that maintains altitude separation between aircraft to avoid mid-air
collisions.
%
(3) Replace is another program that\rq s part of the Siemens suite. Replace searches for a pattern in a given input and
replaces it with another input string.
%
(4) NanoXML is an XML Parser written in Java which consists of 129 procedures and 4608 lines of code.
%
(5) Siena~(Scalable Internet Event Notification Architecture) is an Internet-scale event notification middleware for
distributed event-based applications~\cite{siena} which consists of 94 procedures and 1256 lines of code.
%
(6) Schedule2 is a priority scheduler which consists of 27 procedures and 306 lines of code.
%
(7) PrintTokens2 is a lexical analyzer which consists of 30 procedures and 570 lines of code.
%
(8) ApacheCLI~\cite{apachecli} provides an API for parsing command lines options passed to programs.
It consists of 183 procedures and 3612 lines of code.
%
(9) MerArbiter models a flight software component of NASA JPL\rq s Mars Exploration Rovers.
%
%It was originally modeled in Simulink/Stateflow and automatically translated into Java using the Polyglot framework.
%
We used the version made
available by Yang et al.~\cite{memoise}. This benchmark consists of 268 classes, 553 methods, 4697 lines of code
including the Polyglot framework.
%
While none of our existing benchmarks performed multi-threaded execution, path-merging can interfere with symbolic
execution of multi-threaded programs.
%
We plan to explore this extension of path-merging for symbolic execution of multi-threaded programs in the future.

We first ran each of these benchmarks using SPF with increasing number of symbolic inputs and obtained the most number
of symbolic inputs with which SPF explored all execution paths in each benchmark within a 24 hour time budget.
%
We then ran each benchmark with this number of symbolic inputs with \tool.
%
This evaluation allowed us to check if \tool\ is faster than SPF at exploring all feasible paths through each benchmark.
%
%Next, we used the fastest mode of \tool\ to check if it could explore the benchmark with even more symbolic inputs within
%the same 12 hour time budget.\vaibhav{Figure out if these results need to be reported}
%
We report results from this evaluation for each benchmark in Table~\ref{table:results-all-mode5}.
%
%While static analysis performance can cause \tool\ to be slower on benchmarks with a small number of execution
%paths, we observed that the cost of static analysis gets amortized as the number of execution paths increases.
%
\input{tables/results-all-mode5}
%
\input{tables/comparison-tables}
%
Table~\ref{table:results-all-mode5} shows that \tool\ achieves a significant speed-up over SPF with
5~(WBS, TCAS, NanoXML, ApacheCLI, MerArbiter) of the 9 benchmarks in terms of both running time and number of
execution paths.
%
\tool\ also achieves a modest 22\% reduction in running time and 34\% reduction
in the number of execution paths with the PrintTokens2 benchmark.

\tool\ is able to summarize the entire step function of WBS and TCAS into a single execution path.
%
This step functions of WBS and TCAS take 3 and 12 symbolic inputs respectively.
%
In WBS, \tool\ summarizes multi-path regions with deeply nested {\tt if} bytecode instructions, in one case
summarizing a region that consisted of 9 branches nested within one another.
%
In TCAS, \tool\ inlines 28 method summaries in each step of TCAS, many of which summarize multiple return values
into a single formula that represents all the return values of the method.
%
While SPF does not finish more than 5 steps of WBS and 2 steps of TCAS within 24 hours, \tool\ finishes 10 steps of both
benchmarks within 2.81 seconds and 1.41 seconds respectively.

In the replace benchmark, while \tool\ reduces the number of execution paths by about 88\%, it incurs an increase in
execution time.
%
This increase occurs even when \tool\ transforms 20 distinct regions into 7334 canonical region summaries.
%
On manually investigating the set of instantiated regions in replace, we found that the outputs of most of these
regions were being branched on later in the code causing the benefit from path-merging to be lost.
%
In order to test this hypothesis, we ran an automated evaluation where we restricted \tool\ to only a subset of
regions.
%
First, we determined the most number of symbolic inputs with which \tool\ could explore all paths in replace in less
than a minute.
%
We found this number to be 6 symbolic inputs which took \tool\ about 37 seconds while using 14 regions.
%
Next, we constructed a list of region subsets sorted in increasing order of the subset size.
%
This list began with 14 region subsets, each containing one region, and ended with a single set containing all 14 regions.
%
The total number of region subsets present in this list was $2^{14}-1$.
%
Finally, we ran \tool\ with every region subset in this list, where \tool\ was allowed to only canonicalize regions
within a given subset.
%
After running this evaluation for 96 hours, we found that all possible region subsets containing up to 4 regions had
been tested.
%
But, no region subset up to 4 regions in size resulted with a reduction in the running time and number of execution
paths.
%
While it is possible that there is a larger set of regions in the replace benchmark that provides the most benefit
from path-merging, our automated evaluation and a manual investigation did not reveal what such a set of regions might be.
%
In the future, we plan to integrate a query count estimated heuristic of the kind proposed by
Kuznetsov et al.~\cite{kuznetsov} to canonicalize only a beneficial set of regions in the replace benchmark.

On the NanoXML benchmark, \tool\ finds several opportunities for execution path count reduction on account of the
NanoXML benchmark having several methods with multi-path regions that have a control-flow returning instruction on every
branch side.
%
Since \tool\ can convert such multiple control-flow returning exit points regions into a single control-flow
returning exit point, \tool\ is able to inline more than 8,000 method summaries when running NanoXML with 8 symbolic
inputs and finish in about 8 hours while vanilla SPF needs about 18 hours to explore all feasible paths.

\tool\ has the same performance as SPF on Siena and Schedule2 with a minor overhead~(about 5\% in running time) in
running time that comes from \tool\rq s lookup of a region summary for every executed branch instruction, recording of
metrics, and from doing JIT static analysis to recover region statements.
%
We restrict our results with Siena to 7 symbolic inputs because 7 is the most number of symbolic inputs for which
SPF finishes exploring all feasible paths within a 24 hour time budget.
%
We do not attempt to construct a fully linearized form of a region summary if it does not begin on a symbolic conditional
branch.

In the PrintTokens2 benchmark, \tool\ uses 4 distinct regions, 2 of which involve summarizing multi-path regions which
have a {\tt return} instruction at the end of every path in the region.
%
Being able to summarize multiple control-flow returning exit points into a single such exit point proves to be a crucial
feature in \tool\ for this benchmark.

The ApacheCLI benchmark takes 9 inputs, the first 8 are 1-byte inputs used to construct command-line options and
the last input controls whether ApacheCLI should stop on encountering an invalid option input.
%
Since the 9th input is different from the first 8, we ran ApacheCLI with the first 6 inputs and the 9th input
made symbolic.
%
\tool\ finishes exploration with this setup of ApacheCLI in about 1.5 hours whereas SPF finishes exploration in about 9
hours as shown in Table~\ref{table:results-all-mode5}
%
When we ran SPF on ApacheCLI with the first 7 inputs and the 9th input made symbolic, it was unable to explore all
feasible paths in ApacheCLI within 24 hours.
%
But, \tool\ can complete this exploration in about 15 hours.

In the MerArbiter benchmark, the most significant benefit from \tool\ comes from its ability to summarize multi-path
regions that put their output on the stack directly.
%
Such regions are common in Java bytecode since the JVM is both a stack machine and a register machine.
%
All the multi-path regions that SPF~(which is mode 1 in \tool) needs to branch on but are summarized by \tool\ are
regions that compute a boolean value based on a symbolic branch and write it to the stack as an operand to be used
by the following return instruction.
%
Most of these multi-path regions lie inside several levels of nested classes and dynamically bound field references
that necessitate a fixed-point computation over the field substitution and constant propagation transformations.
%
\tool\ summarizes such multi-path regions and does 411,000 instantiations with 7 steps of MerArbiter (each step takes 4
symbolic inputs), with more than 282,000 instantiations needing more than 8 iterations of the fixed-point computation.

\tool\ has different path-merging features such as summarizing multi-path regions with a single non-returning exit
point, inlining method summaries, exploring unsummarized behavior using single-path cases, and summarizing multiple
control flow-returning exit points into a single such exit point.
%
We wanted to evaluate the effect each feature has when it is added to a previous set of features.
%
We set up an experiment where beginning with no path-merging (aka baseline SPF), we added path-merging features in the
aforementioned order.
%
For every benchmark where any path-merging was performed, we computed the ratio of three metrics with a set of
path-merging features enabled to the same metrics without path-merging (aka when only baseline SPF was used).
%
These three metrics were: the running time, the number of execution paths explored, and the number of solver calls made.
%
We present the results of this comparison in Table~\ref{table:comparison-table}.
%
Table~\ref{table:comparison-table} shows that merging of paths for regions that have a single non-returning exit point
is most often useful.
%
This observation matches our intuition that regions are most commonly present in Java.
%
The addition of method summary inlining provides a major reduction in all three metrics in TCAS.
%
This observation matches a observation made manually from TCAS' source code that multi-path regions in it often invoke
methods that can be summarized by \tool\.
%
The addition of single-path cases provides a major reduction in the number of solver queries in the replace and
NanoXML benchmarks.
%
But, it also causes a minor increase in the running time of both of these benchmarks.
%
We attribute this increase to the fact that the reduction in the number of solver queries is not enough to compensate
for the increase in complexity of the solver queries introduced with single-path cases.
%
In the future, we plan to address this issue by transforming region summaries with more sophisticated term rewriting
and context-specific simplification of canonical regions to reduce the complexity of solver queries.
%
The addition of summarizing multiple control flow-returning exit points into a single such exit point provides a
significant reduction in the number of execution paths and number of solver queries in the NanoXML, PrintTokens2
benchmarks.
%
The benefit from this feature matches our observation that both of these benchmarks contain frequently-executed
regions that contain multiple control-flow returning exit points.
%
In conclusion, Table~\ref{table:comparison-table} shows that every path-merging feature present in \tool\ has a
beneficial impact on atleast one benchmark in our set.
%
It demonstrates the benefits from our re-interpretation and extension of the original veritesting approach~\cite{veritesting}
for symbolic execution of Java bytecode.