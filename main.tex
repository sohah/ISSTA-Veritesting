\documentclass[sigconf,review, anonymous]{acmart}
\acmConference[ESEC/FSE 2019]{The 27th ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering}{26--30 August, 2019}{Tallinn, Estonia}

\usepackage{booktabs} % For formal tables
%\usepackage{backnaur}
\usepackage{syntax}
\usepackage{calc}
\usepackage{listings}
\usepackage{url}
\usepackage{color}
\usepackage{graphicx}
%\usepackage{subcaption}
\usepackage{subfig}
\captionsetup{compatibility=false}
\usepackage{amssymb,proof}
\usepackage[]{algorithm2e}


%\newenvironment{bnfsplit}[1][0.7\textwidth]
%{\minipage[t]{#1}$}
%{$\endminipage}


%\renewcommand{\baselinestretch}{0.945}
%\newcommand*\samethanks[1][\value{footnote}]{\footnotemark[#1]}

% Copyright
%\setcopyright{none}
% \setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
% \setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}


% DOI
% \acmDOI{10.475/123_4}

% ISBN
% \acmISBN{123-4567-24-567/08/06}

%\acmPrice{15.00}

\newcommand{\unit}{ ( ) }
\newcommand{\rn}[1]{\scriptscriptstyle\mathtt{#1}}
\newcommand{\compose}[2]{#1 \; ; \; #2}
\newcommand{\return}[1]{return\: #1}
\newcommand{\throw}[1]{throw\: #1}
\newcommand{\ifr}[3]{if \; #1 \; then \; #2 \; else \: #3}
\newcommand{\rstate}[2]{#1 \:,\: #2}
\newcommand{\step}[5]{\rstate{#1}{#2}\ \mapsto_{#5}\ \rstate{#3}{#4}}
\newcommand{\lookup}[2]{#1(#2)}
\newcommand{\sub}[3]{[#1/#2]#3}


\begin{document}

\newcommand{\mike}[1]{\textcolor{red}{#1}}
\newcommand{\vaibhav}[1]{\textcolor{red}{#1}}
\newcommand{\soha}[1]{\textcolor{red}{#1}}
\newcommand{\smcc}[1]{\textcolor{red}{#1}}

\newcommand{\toolshort}{JR}
\newcommand{\tool}{Java Ranger}
\newcommand{\toolfull}{Java Ranger}

\title{\tool: Static Regions for Efficient Symbolic Execution of Java}

\author{Vaibhav Sharma}
\authornote{Both authors contributed equally to this research.}
\email{vaibhav@umn.edu}
\author{Soha Hussein}
\authornotemark[1]
\email{husse200@umn.edu}
\affiliation{%
\institution{University of Minnesota}
\city{Minneapolis}
\state{MN}
\postcode{55455}
\country{USA}
}

\author{Michael W. Whalen}
\affiliation{%
\institution{Amazon Web Services}
\city{Minneapolis}
\state{MN}
\country{USA}}
\email{mww@amazon.com}

\author{Stephen McCamant}
\affiliation{%
\institution{University of Minnesota}
\city{Minneapolis}
\state{MN}
\postcode{55455}
\country{USA}
}
\email{smccaman@umn.edu}

\author{Willem Visser}
\affiliation{%
\institution{Computer Science Division, University of Stellenbosch}
\city{Stellenbosch}
\country{South Africa}}
\email{wvisser@cs.sun.ac.za}

\maketitle
\begin{abstract}

%Scaling symbolic execution to industrial-sized programs is an important open research problem.  Veritesting introduced bounded static regions in symbolic execution to improve scalability by combining the advantages of static symbolic execution with those of dynamic symbolic execution.  Bounded static regions reduce the number of paths to explore in symbolic execution by describing regions of code using disjunctive formulas.
%%
%In previous work, veritesting was applied to binary-level symbolic execution.

%Integrating veritesting with Java bytecode presents unique challenges, 
%notably, incorporating many more non-local control jumps caused by runtime polymorphism, exceptions, native calls, and dynamic class loading.
%%
%If these languages features are not accounted for, the static code regions described by veritesting are often small and may not lead to substantial reduction in paths.  In addition, the use of disjunctive regions forces previously concrete assignments to become symbolic leading to additional solver calls.  

%In this paper, we describe \tool, which adds static regions to Java Symbolic Pathfinder.  Unlike previous approaches, it adds support for {\em higher order} Veritesting regions into which we can instantiate static regions for staticly- and dynamically-dispatched function calls.  Although our tool is still an unoptimized prototype, we show that it dramatically outperforms Java Symbolic Pathfinder on a number of benchmark examples, and that support for higher-order regions substantially improves the performance of Veritesting for Java programs.

Merging related execution paths is a powerful technique for reducing
path explosion in symbolic execution.
%
One approach, introduced and dubbed ``veritesting'' by Avgerinos et
al., works by statically translating a bounded control flow region
into a single formula.
%
This approach is a convenient way to achieve path merging as a
modification to a pre-existing single-path symbolic execution engine.
%
Avgerinos et al. evaluated their approach in a symbolic execution tool
for binary code, but different design considerations apply when
building tools for other languages.
%
In this paper we explore the best way to use a veritesting approach in
the symbolic execution of Java.

Because Java code typically contains many small dynamically dispatched
methods, it is important to include them in veritesting regions; we
introduce a {\em higher-order} veritesting technique to do so
modularly.
%
Java's typed memory structure is very different from a binary, but we
show how the idea of static single assignment (SSA) form can be
applied to object references to statically account for aliasing.
%
More formally, we describe our veritesting algorithms as
syntax-directed transformations of a structured intermediate
representation, which highlights their logical structure.
%
We have implemented our algorithms in \tool, an extension to the
widely used Symbolic Pathfinder tool for Java bytecode.
%
Our empirical evaluation shows that veritesting greatly reduces the
search space of Java symbolic execution benchmarks, while our expanded
capabilities provided a significant further improvement.



\end{abstract}

%\keywords{multi-path symbolic execution; veritesting; Symbolic
%PathFinder; static analysis}


\input{introduction}
%\input{preliminaries}
%\input{challenges}
\input{related-work}
\input{technique}
%\input{experiments}
\input{evaluation}
\input{discussion}
\input{conclusion}

\bibliographystyle{ACM-Reference-Format}
\bibliography{references}
\newpage
\clearpage
\input{appendix}

\end{document}
