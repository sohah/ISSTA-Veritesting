\section{Technique}
%

%\begin{figure}
\begin{algorithm}[]
\SetAlgoLined
%\KwResult{Write here the result }
Input: Region R\;
 somethingChanged = true\;
 execute early-return transformation(R)\;
 execute alpha-renaming transformation(R)\;
 \Repeat{!(somethingChanged)}
 {
	\While{(somethingChanged)}{
		execute substitution transformation(R)\;
		execute high-order transformation(R)\;
		execute fields transformation(R)\;
		execute arrays transformation(R)\;
		execute references alpha-renaming transformation(R)\;
		execute simplification transformation(R)\;}
	execute high-order transformation(R)\;}
	execute single-path cases(R)\;
	execute linearlization transformation(R)\;
	execute to-green transformation(R)\;
	\eIf{R successfully transformed}{populate output\;}{abort\;}
	populate output\;
 \label{fig:algorithm}
  \caption{Ranger general pesudo-code}
\end{algorithm}
%\end{figure}

%
To add path merging to SPF, we first pre-compute static summaries of arbitrary code regions with more than one execution
path and we also pre-compute method summaries. 

Figure~\ref{fig:algorithm} describes the main steps that Java Ranger deploys to summarize the region. Intuitively, Java Ranger starts with a symbolic multi-path region expressed in Ranger grammar~\ref{fig:grammar} (described in section~\ref{sec:static-analysis}). Java Ranger then proceeds as follows, first it performs early return transformation, by eliminating eliminating return statements, this is followed by alpha-renaming on variables in the region. Then Java Ranger enters two fix-point loops, the inner loop terminates when no further changes is detected on the region after repeatedly applying substitution, high-order, fields, arrays, reference alpha-renaming and simplification transformations. can be made on the region. The outer loop ensures that at least one step of high order region was attempt without further changes before it declares reaching a fixed point. 

After reaching a fixed point, single path cases are determined, then flattening the IR of the region to a sequence of assignment statements followed by a transformation that transforms the region into the corresponding solver syntax using Green. Finally if all transformations were successful then Java Ranger populates the output to SPF and advances it to the right position, otherwise it aborts. 

In the following sections, we describe each of the transformations performed by Java Ranger both formally by defining the semantics of each transformation and informally by showing how each transformation is realized on our example~\ref{fig:mot-example}

%%
%To bound the set of code regions we analyze, we start by specifying a method $M$ in a configuration file.
%%
%Next, we construct a set containing only the class $C$ that contains $M$.
%%
%We then get another set of classes, $C'$,
%such that every class in $C'$ has at least one method that was called by a method in a class in $C$.
%%
%This step which goes from $C$ to $C'$ discovers all the classes at a call depth of 1 from $C$.
%%
%We continue this method discovery process up to a call depth of 2.
%%
%While we can increase the call depth in our method discovery process, we found that summarizing
%arbitrary code regions with more than 2 calls deep, did not lead to practically useful region summaries.
%%
%After obtaining a list of methods, we computed static summaries of regions in these methods and method summaries as
%explained in Section \ref{sec:static-analysis}.
%%
%After computing static region and method summaries, we process them as a sequence of transformations described in the next section~\ref{sec:instantiationTransformations} and summarized
%in Figure~\ref{fig:overview}.
%%


\begin{figure*}[]
    \caption{Overview of transformations on Ranger IR to create and instantiate regions up to a fix-point.}
    \label{fig:overview}
    \includegraphics[width=1.5\columnwidth]{figures/transformations.pdf}
\end{figure*}
%
%
%\subsection{WALA-based analysis for veritesting}
%%
%Veritesting requires static construction of
%predicates of a multi-path region which represent changes to the path expression of the dynamic
%symbolic executor.
%%
%It also requires construction of a control-flow graph of method bodies
%from Java bytecode and finding exit points of the region, which in turn
%requires creation of a control-flow graph of the region.
%%
%Implementing veritesting is made simpler by using a static single
%assignment~(SSA)~\cite{ssa} representation of the multi-path region.
%%
%Using an SSA form allows us to use the $\phi$-expressions created by the
%SSA form and translate them into points at the end of the veritesting
%region where updates to system state along different paths in the region
%can be merged.
%%
%\mike{MWW: Vaibhav please update to describe WALA}
%WALA~\cite{} is a static analysis framework for Java programs that
%has both these features, with
%ExceptionalUnitGraph~\cite{exceptionalunitgraph} and the Shimple
%IR~\cite{shimple}.
%%
%For simple regions with only one exit point, like the one presented in Listing~\ref{lst:v_ex}, we
%were able to use Soot to automate static construction of the predicate representing
%an update to the expression.
%%
%For doing this, we used nodes with more than one successor as the
%starting point, found the immediate post-dominator of the starting
%point, and traversed the control-flow graph on all sides of such branches.
%%
%During such a traversal, we constructed predicates representing the
%multi-path region, similar to the ones presented in
%Listing~\ref{lst:v_ex_smt2}.
%%
%As explained in Section~\ref{sec:exit_points}, including virtual
%function invocations in the construction of our predicates amplifies the
%benefits of veritesting even further.
%%
%We plan to automate this inclusion in the future using Soot.
%%
%Providing SPF with updates to be made to its symbolic store also
%requires Soot to maintain stack location information for variables.
%%
%We plan to automate SPF\rq s symbolic store updates using Soot in the
%future.
%%
%

\subsection{Statement Recovery}
\label{sec:static-analysis}
\begin{figure}
\begin{grammar}
<stmt> ::= <stmt> ; <stmt> | <exp> := <exp> | skip | x.<stmt> 
\alt <exit_stmt> | if <exp> then <stmt> else <stmt> 
\alt invoke( <exp>, <exp>, <exp> )  | exit

<exit-stmt> ::=  new $\tau$  | return <exp> |  throw <exp> 

<exp>  ::= <val> | <var> | <exp> $op_b$ <exp> | $op_u$ <exp>
\alt get_field( <exp>, <exp> ) | put_field( <exp>, <exp> )
\alt array_load( <exp>, <exp>, <exp> )  
\alt array_store( <exp>, <exp>, <exp> ) 
\alt gamma( <exp>, <exp>, <exp> ) 

<$op_b$> ::= $+$ | $-$ | $*$ | $\div$ | \& | bitwise-or | $\oplus$ | \% | $==$ | $\neq$ | $\leq$ | $\geq$ | \&\& | logical-or | \textgreater | \textless | $\ll$ | $\gg$ | $\ggg$

<$op_u$> ::= $-$ | \textasciitilde

<val> ::= \unit | $\mathbb{Z}$ |  $\mathbb{C}$

<var> ::= ID_$\mathbb{N}$
\end{grammar}
\caption{Context Free Grammar for Java Ranger IR}
\label{fig:grammar}
\end{figure}


\begin{figure}
$$
\begin{array}{lllll}
\text{value-maps} & \Delta_r: loc \rightarrow & ( val, exp) &&
\\
& \Delta_s: loc \rightarrow & ( val, exp) &&
\\
\text{type-maps}  & \Gamma_r: var \rightarrow & \tau & &
\\
& \Gamma_s: ref \rightarrow & \tau&&
\\
\text{region-map} & \Psi: \tau \rightarrow & x.s &&
\\
& \Theta: var \rightarrow & loc &&
\\
\text{single-path-constraints} & \Sigma: \{exp\} &  &  & 
\\
\text{early-return-constraints} & \Sigma_{ret}: x_{ret} & \{exp\} &  & 
\end{array}
$$
\caption{Environments used in Ranger.}
\label{fig:environment}
\end{figure}

%Java Ranger has its own AST that captures the statement of regions.
%%
%The choice of having a separate AST for Java Ranger, enables the integration of Java Ranger with any static analysis framework by implementing the transformation that transforms the CFG of a given IR into the corresponding Java Ranger AST representation. 
%%
%We call this interface \textit{Statement Recovery} transformation. \\
%%
%In this transformation we visit nodes in topological order by walking normal edges of a branching points until a \textit{minimum convergent node} is encountered. We define a minimum convergent node as the last immediate successor of blocks following a branching node.
%%
%Note that exceptional edges are ignored during this transformation, however exceptional behavior is later identified and handled through the single path cases.
%%
%We discuss more about this in section~\ref{sec:instantiationTransformations}.
%%
%There are two other things that this transformation takes care of: recovering of complex if-then-else and construction of Gated Single Assignment (GSA).
%%
%Recovering of complex conditions in an if-statement restores its form in the source code. 
%% 
%This is done by identifying \textit{immediate self-contained subgraphs}, that is, subgraphs where the initial node is immediately pre-dominated by the initial node and for the static region and whose successor nodes (up to the region terminus) are dominated (not necessarily immediately) by the initial node.
%%
%
%Construction of Gated Single Assignment (GSA) on the other hand is done by keeping track of the current "conditional path" during translation. More precisely this is done by keeping a stack of  {\tt(Expression x enum \{Then, Else\})} pairs. 
%%
%In addition to that, for each edge between blocks in the block structure, the associated "conditional path" is recorded.  
%%
%So the type of this map (the blockConditionMap) is: {\tt(ISSABasicBlock x ISSABasicBlock) --> List of (Expression x enum \{Then, Else\})}.
%%
%Finally creation of the condition of GSA is done during translating a phi-instruction its immediate predecessor blocks are retrieved then we look up  the edges in the blockConditionMap.  From here, and using condition stack leading to that branch, an if/then/else statement is constructed.

In this step, a Java Ranger is created from the corresponding CFG. Since regions of interest for our technique are bounded by the branch and meet of a given acyclic subgraph.  The intuition is that path explosion during execution of loops is driven by conditional logic within the loop, rather than the loop itself.
Starting from an SSA form, the first transformation recovers a tree-shaped AST for the subgraphs of interest.  While this step is not strictly necessary, it substantially simplifies subsequent transformations.  

The algorithms are similar to those used for those used for decompilation~\cite{Yakdan15@decompilation} but with slightly different goals: 
\begin{itemize}
    \item The algorithm must be {\em accurate} but need not be {\em complete}.  That is, obfuscated regions of code need not be translated into a tree form.
    \item The algorithm must be {\em lightweight} in order to be efficiently performed during analysis.  Thus, algorithms that use global fixpoint computations are 
        too expensive to be used for our purposes.
\end{itemize}

Starting from an initial SSA node, the algorithm first finds the immediate post-dominator of all {\em normal} control paths, that is, paths that do not end in an exception or return instruction.  It then looks for nested self-contained subgraphs.  If for any graph, the post-dominator is also a predecessor of the node, we consider it a loop and discard the region.  

The algorithm systematically attempts to build regions for every branch instruction, even if the branch is already contained within another region.  The reason is that it may not be possible to instantiate the larger region depending on whether summaries can be found for {\em dynamically-dispatched} functions, and whether references are {\em uniquely determinable} for region outputs.

The outcome of this step is a statement in Java Ranger grammar~\ref{fig:grammar}. Basically the grammar is composed of statements $stmt$ and expressions $exp$. Statements in Java Ranger contains: sequential composition ($stmt;stmt$), assignment ($exp = exp$), a skip, parametric statements $x.stmt$, exit-statements $exit$, which determine single path regions and they are $new\; \tau$, $throw\; exp$ and $return\; exp$, if-then-else, method invocation $invoke(exp, exp, exp)$ and especial $exit$ statement to bookmark exit point of a region/statement. 

Java Ranger expressions on the other hand are: values (unit \unit, positive and negative integers $\mathbb{Z}$ and characters $\mathbb{C}$) , variables (these are subscripted with integers to facilitate having ssa form for vars D_$\mathbb{N}$), binary operations $op_b$, unary operations $op_u$,  $get-field(exp, exp, exp)$ and $put-field(exp, exp, exp)$ for accessing and changing fields,  $array-load(exp, exp, exp)$ and  $array-store(exp, exp, exp)$ for accessing and changing array elements, a special gamma expression, $gamma(exp, exp, exp)$, that operates like $?:$ in Java. Gamma expression are fundamentally important to Java Ranger because it is how Java Ranger determines the conditions of different paths as well as the evaluation of variables along these paths.  
It worth pointing out that Java Ranger defines 3 types of variables, a field or array variable (created to maintain fields and arrays ssa), an early return variable (to carry early return values) and any other type of variables. We assume the existance of a special function $gen_var$ that would generate one variable in the right sequence for each of these types. 

In the remaining sections we will use $x$ to range over any type of variable, $x_{ref}$ to variables constructed for fields and arrays and $x_{ret}$ for variables constructed for early return construction. Similarly we will use $s$ to range over statements, $e$ to range over expressions and $v$ to range over values.
\iffalse
\begin{verbatim}

stmt ::= stmt ; 
   

\end{verbatim}

\vaibhav{assigned to Mike}
\mike{MWW: - we should provide an AST of the constraint language}
\fi 


\subsection{Region Definition}

Once the statement of a multi-path region has been recovered, its corresponding environment is populated.
%
This includes identifying region boundary and creating local variable inputs, outputs, type, and stack slot tables for
the region.
%
The region boundary is used to identify boundaries of the region w.r.t local variables.
%
This is used later to constrain the computation and population of Ranger IR environment tables.
%
For example, the local variable input table is populated with first \textit{use} in the region boundary that map to a given stack slot.
%
The output table is populated with the last \textit{def} of a local variable at merge point of the region.
%
The local variable type table is populated for all variables that lay within the boundaries of the region, this is initially done by
inquiring the static analysis framework, WALA~\cite{Wala} but is later changed by inferring types of local variables
at instantiation and during type propagation transformation~\ref{sec:instantiationTransformations}.

We also construct a stack slot table as part of a region\rq s Ranger IR summary.
%
The stack slot table maps Ranger IR variables to a stack slot, if they correspond to a local variable in the source code.
%
We populate the stack slot table by obtaining a variable to stack slot mapping from WALA.
%
We also assume that, if at least one variable used in a $\phi$-expression is a local variable, then all variables
used in that $\phi$-expression must belong to the same stack slot.
%
We use this assumption to further propagate stack slot information in the stack slot table across all $\phi$-expressions
encountered at merge points of regions.


Formally we define the following structures: \\
\textbf{value-map}: Java Ranger and SPF value map $\Delta_r$ and $\Delta_s$  that maps location, i.e., stack slots, to concrete values $val$ or symbolic values $exp$. \\
\textbf{type-map}: Java Ranger and SPF value map $\Gamma_r$ and $\Gamma_s$  that maps vars or references, to types $\tau$.\\
\textbf{region-map}: Java Ranger defines a map $\Psi$ from type $\tau$  to a parametric statement $x.s$ that defines the parameteric statement region in Java Ranger.\\
\textbf{Single-Path-Constraint-List}: A list $\Sigma$ of single-path constraints.\\
\textbf{Early-Return-Constraint-map}: A map $\Sigma_{ret}$ from early-return vars $x_{ret}$ to early-return constraints.

%The stack slot table on the other hand, does not use region boundary for its population. The reason for this is that,
%the static analysis framework we use, WALA, sometime does not provide information about the stack slots of intermediate
%variables.
%%
%This is particularly problematic in our case because the def of a phi is both an intermediate variable, and so we do
%not know its stack slot, yet it is also an output of the region for which we want to populate its symbolic
%representation onto the stack slot.
%%
%Therefore, our stack slot table uses stack slot inference by propagating the stack slots of vars used in a phi onto the
%def of the phi.
%%
%This requires visiting all variables and phi statements of the IR to maximize the inference of the stack slot, this is
%repeatedly done until a fix point is reached.


\begin{figure*}[t]
\fbox{%
\parbox{0.98\textwidth}{%
$$
\infer[\rn{substitution}]
 {\step{\Theta, \Delta_s}{x.s}{\Theta, \Delta_s}{\sub{(v,e)}{x}{s}}{sub}}
 {\lookup{\Theta}{x} = l , \quad \lookup{\Delta_s}{l}=(v,e)}
\qquad
 \infer[\rn{single-path_1}]
 {\step{}{throw e}{}{exit}{single}}
 {}
$$
$$
\infer[\rn{high-order_1}]
 {\step{\Gamma_r, \Delta_r}{s_1; invoke(e_1, e_2)}{(\Gamma_r \cup \Gamma_r'), \Delta_r''}{s_1; \sub{v_2}{x}{s_1}}{high}}
 {\step{\Gamma_r, \Delta_r}{e_1}{\Gamma_r, \Delta_r'}{v_1}{sub} \quad \lookup{\Gamma_s}{v_1} = \tau , \quad \Gamma_r', \lookup{\Psi}{\tau}=x.s_2, \quad \step{\Delta_r'}{e_2}{\Delta_r''}{v_2}{sub}}
$$
$$
\infer[\rn{high-order_2}]
 {\step{\Gamma_r, \Delta_r}{e = invoke(e_1, e_2)}{(\Gamma_r \cup \Gamma_r'), \Delta_r''}{\sub{v_2}{x}{s} ; e = e'}{high}}
 {\step{\Gamma_r, \Delta_r}{e_1}{\Gamma_r', \Delta_r'}{v}{sub}, \quad \lookup{\Gamma_s}{v} = \tau, \quad \Gamma_r', \lookup{\Psi}{\tau}= x.(s; \return{e'}), \quad \step{\Delta_r'}{e_2}{\Delta_r''}{v_2}{sub}}
$$
$$
\infer[\rn{single-path_2}]
 {\step{\Sigma}{\ifr{e}{(s_1 ; exit ; s_1' )}{s_2}}{(\Sigma \vee e)}{s_2}{}}
 {}
\qquad
\infer[\rn{single-path_3}]
 {\step{\Sigma}{\ifr{e}{s_1}{(s_2 ; exit ; s_2')}}{(\Sigma \vee !e)}{s_1}{}}
 {}
$$
$$
\infer[\rn{single-path_4}]
 {\step{\Sigma}{\ifr{e}{(s_1 ; exit ; s_1' )}{s_2 ; exit ; s_2'}}{(\Sigma \vee true)}{skip}{}}
 {}
 \qquad
\infer[\rn{linearlization}]
 {\step{\Sigma}{\ifr{e}{s_1}{s_2}}{\Sigma}{\compose{s_1}{s_2}}{}}
 {}
$$
$$
\infer[\rn{to-green}]
 {\step{\Sigma}{x := gamma(e_1, e_2, e_3)}{\Sigma}{( e_1 \wedge x = e_2) \vee ( !e_1 \wedge x = e_3)}{}}
 {}
$$
$$
\infer[\rn{early-return_1}]
 {\step{\Sigma_{ret}}{\ifr{e_1}{s_1}{(s_2 ; \return{e_2})}}{\Sigma_{ret} \cup (x_{ret}, e_2)}{(\ifr{e_1}{(s_1 ; \return{e_2})}{s_2}) ; x_{ret} := e_2}{}}
 {gen\_id(ret) = x_{ret} \qquad x_{ret}'' \notin s_1 \qquad x_{ret}' \notin s_2}
$$
$$
\infer[\rn{early-return_2}]
 {\step{\Sigma_{ret}}{\ifr{e_1}{s_1}{s_2}}{\Sigma_{ret} \cup (x_{ret} (e_1\wedge c_1)\vee( e_1 \wedge c_2))}{(\ifr{e_1}{(s_1 ; \return{e_2})}{s_2}) ; x_{ret} = gamma((c1 \wedge e_1), e_1',  e_2')}{}}
 {\step{\Sigma}{s_1}{\Sigma_{ret}: (w1_{ret},c_1)}{s_1' ; w1_{ret} := e_1''; \return e_1'}{}  \quad
  \step{\Sigma}{s_2}{\Sigma_{ret}: (w2_{ret}, c_2)}{s_2' ; (w2_{ret} := e_2'' ; \return e_2')}{} \quad gen\_id(ret) = x_{ret}}
$$
%$$
%\infer[\rn{early-return_3}]
% {\step{\Sigma_{ret}}{\ifr{e}{(s_1 ; \return{e_1})}{(s_2 ; \return{e_2})}}{\Sigma_{ret} \vee true}{\ifr{e}{(s_1 ; \return{e_1})}{skip} ; x_{ret} := e_1}}
% {gen\_id(\_) = x_{ret}}
%$$
}}
\caption{Evaluation Rules for Ranger Transformations}
\label{fig:semantics}
\end{figure*}

\subsection{Instantiation-time Transformations}
\label{sec:instantiationTransformations}

\textbf{Early Return Transformation}: In this transformation, Java Ranger collects that conditions for branches that have early return in them. In figure~\ref{fig:semantics} we show the rule of having an early return on the else side $\rn{early-return_1}$ where neither inner statements $s_1$ or $s_2$ are conditional with early return. In this case, the statement is transformed to appending an assignment statement to the early return result to a new early return var $x_{ret}$, also the condition under which the early return value occurs is added to the early return environment $\Sigma_{ret} \cup (x_{ret}, e_2)$ 

Rule $\rn{early-return_2}$ describes the situation where both the statements $s1$ and $s2$ contains inner conditions with early return statements. In this case a new result variable is created $x_{ret}$ and assigned to the gamma expression $x_{ret} = gamma((c1 \wedge e_1), e_1',  e_2')$ describing conditions and values assigned under them. In addition the context of early return variables-conditions is updated. 

\textbf{Renaming Transformation}: In Alpha renaming transformation, all Ranger IR variables are renamed to ensure their uniqueness before further processing takes place. 
%
This is particularly important not only to ensure uniqueness of variables among different regions, but also to ensure
uniqueness of variable names of the \textit{same} region which might be instantiated multiple times on the same path,
i.e., a region inside a loop will be instantiated multiple times.

We do not define this transformation formally due to space, but it is basically straight forward by generating a unique prefix for each variable and updates the new name in the statement as well as all the contexts in which it appears.  \\
%
\textbf{Local Variable Substitution Transformation}: During this transformation we eagerly bring in all dynamically
known constant values, symbolic values and references from stack slots into the region for further processing. \\
More formally, rule $\rn{substitution}$ given a parametric statement $x.s$, and if $x$ was mapped to a location $l$ then its dynamic, i.e., concrete or symbolic $(v, e)$, substitute $x$ in $s$.\\
%
\textbf{Higher-order Regions Transformation}: This transformation is initiated when a method invocation is encountered
during local variable substitution.
%
At this point, we perform three steps.
%
(1) the region that corresponds to the called method is retrieved and alpha renaming of
Ranger IR variables corresponding to local variables is applied on it.
%
(2) Ranger IR expressions that correspond to the actual parameters are evaluated and used to substitute the formal
parameters by repeatedly applying local variable substitution transformation over the method region.
%
(3) When no more higher-order regions can be inlined, the resulting substituted method region is inlined into
the outer region.\\
%
Formally, rule $\rn{high-order_1}$ describes the inlining process for methods that has no return values, and $\rn{high-order_2}$ describes inlining of methods that have a single return values. Methods of multiple returns, should have been normalized out with the early-return transformation discussed previously. For $\rn{high_order-1}$ initially 
\\
\textbf{Field References SSA form}: The field references transformation translates reads and writes of fields
in Java bytecode into corresponding Ranger IR statements.
%
In order to translate all field accesses to SSA form, this transformation creates a summary of the semantics
represented by the field accesses in the region.
%
This transformation constructs a new field access variable for every field assignment on every path within the region.
%
This new field access variable construction makes use of two monotonically increasing subscripts.
%
It uses a path subscript to distinguish between assignments to the same field on the same execution path.
%
It uses a global subscript to distinguish between assignments to the same field across execution paths.
%
At the merge point of the region, field assignments done on the same field are merged using
Gated Single Assignment (GSA)~\cite{Ottenstein1990}.
%
Each merged field access variable has its own path and global subscripts and represents the output of the region into
its field.
%
The path subscript helps us resolve read-after-write operations on the same execution path and find the latest write
into a field on an execution path.
%
The global subscript helps us distinguish between field accesses across multiple execution paths. \\
\textbf{Array References SSA form}: The array references transformation translates reads and writes of arrays in
Java bytecode into corresponding Ranger IR statements.
%
In order to translate all array accesses to SSA form, this transformation creates an execution path-specific copy of
every array when it is first accessed within a region.
%
Reads and writes of arrays are then done on a path-specific copy of the array.
%
All array copies are merged at the merge point of multi-path regions.
%
The merged array copy represents array outputs of the region.\\
\textbf{Type Propagation}: Ranger IR needs to have type information for its variables so that it can construct
corresponding correctly-typed Green variables during the final transformation of the region summary to a Green formula.
%
Having accurate type information is also important for looking up the correct higher-order method summary.
%
As part of region instantiation, Java Ranger infers types of Ranger IR variables in the region summary by
using JPF's runtime environment.
%
Types of local variables are inferred during the local variable substitution transformation and types of field reference
and array reference variables are inferred during their respective transformations.
%
Using these inferred types, the type propagation transformation propagates type information across assignment
statements, binary operations, and variables at leaf nodes of $\gamma$ functions.\\
%
\textbf{Simplification of Ranger IR}: The Ranger IR constructed by earlier transformations computes exact semantics
of all possible behaviors in the region.
%
Representation of such semantics as a formula can often lead to unnecessarily large formulas, which has the potential to
reduce the benefits seen from path merging~\cite{angr}.
%
For example, if an entry in an array is never written to inside a region, the array reference transformation can still have an
array output for that entry that writes a new symbolic variable into it.
%
The region summary would then need to have an additional constraint that makes the new symbolic variable equal the
original value in that array entry.
%
Such conjuncts in the region summary can be easily eliminated with constant propagation, copy propagation, and constant
folding~\cite{dragon-book}.
%
Ranger IR also has statement and expression classes that use a predicate for choosing between two statements (similar to
an {\tt if} statement in Java) and two sub-expressions (similar to the C ternary operator) respectively.
%
When both choices are syntactically equal, the predicated statement and expression objects can be substituted with the
statement or expression on one of their two choices.
%
Such statements and expressions were simplified away to use one of their two choices.
%
Ranger IR performs these two simplifications on such predicated statements and expressions along with constant folding,
constant propagation, and copy propagation.\\
\textbf{Single Path Cases}: This transformation collects path predicates inside a region that lead to
\textit{non-nominal} exit point.
%
This is an alternative approach to that was presented in \cite{veritesting}.
%
In our work we define non-nominal exit point to be points inside the region that either define exceptional behavior or
involve behavior that we cannot summarize, i.e, object creation and throw instructions.
%
The intuition here is that, we want to maximize regions that Java Ranger can summarize, even if the summarization is
only partial.
%
We use this pass of transformation to identify such points, collect their path predicates and prune them away from the
Ranger IR statement. The formal rules of this transformation is defined in rule $\rn{single-path_1}$ and $\rn{single-path_2}$, where the former transforms statements that are considered exit points, then the later constructs the matching constraints to explore the single path of interest. 
%
The outcome of this process, is a more simplified and concise statement that represent the nominal behavior of the Ranger region.
%
The collected predicate is later used to guide the symbolic execution to explore non-nominal paths, which Java Ranger
had not summarized.  \\
%
\textbf{Linearization}:
Ranger IR contains translation of branches in the Java bytecode to if-then-else statements defined in the Ranger IR.
%
But the if-then-else statement structure needs to be kept only as long as we have more GSA expressions to be
introduced in the Ranger IR.
%
Once all GSA expressions have been computed, the Ranger IR need not have if-then-else statements anymore.
%
The $\gamma$ functions introduced by GSA are a functional representation of branching, which lets us
capture the semantics of everything happening on both sides of the branch.
%
Since the linearization transformation $\rn{linearlization}$ is done after every field and array entry has been unaliased and converted to
GSA, dropping if-then-else statements from the Ranger IR representation of the region summary reduces redundancy in its
semantics and converts it into a stream of GSA and SSA statements.\\
\textbf{Translation to Green}:
%
At this point Ranger region contains only compositional statements as well as assignment statements that might contain GSA expressions in them.
%
This transformation starts off by translating Ranger variables to Green variables of the right type using the region type table.
%
Then Ranger statements are translated. More precisely, compositional statements are translated into conjunction, assignment statements are translated into Green equality expressions.
%
For assignment statements that have GSA expressions $\rn{to-green}$, these are translated into two disjunctive formulas that describes the assignment if the GSA condition or its negation were satisfied. 

\subsection{Checking Correctness Of Region Summaries}
The Ranger IR computed as a result of performing the transformations described in Figure~\ref{fig:overview} should
correctly represent the semantics of the summarized region.
%
If it does not, then using the instantiated region summary can cause symbolic exploration to explore the wrong behavior
of the subject program.
%
We checked the correctness of our instantiated region summaries by using equivalence-checking as defined by Ramos et al.~\cite{ramos}.
%
We designed a test harness that first executes the subject program with a set of symbolic inputs using SPF and
capture the outputs of the subject program.
%
Next, the test harness executes the same subject program with the same set of symbolic inputs using Java Ranger and
capture the outputs of the subject program once again.
%
Finally, the test harness compares outputs returned by symbolic execution with SPF and Java Ranger.
%
If the outputs do not match, then a region summary used by Java Ranger did not contain all the semantics
of the region it summarized.
%
We symbolically execute all execution paths through this test harness.
%
If no mismatch is found between outputs on any execution path, we conclude that all region summaries used by Java Ranger
must correctly represent the semantics of the regions they summarized.
%
We performed correctness-checking on all results reported in this paper.
